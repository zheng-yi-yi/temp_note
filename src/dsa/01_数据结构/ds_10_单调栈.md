---
title: 单调栈
category: 数据结构
tag:
  - 单调栈
icon: carbon:ibm-datastage
order: 10
---

## 用法

单调栈最经典的用法是解决如下问题：

遍历数组元素 `nums[i]`，对于每个元素：

1. 计算左侧比 `nums[i]` 小，且距离最近的位置在哪
2. 计算右侧比 `nums[i]`小，且距离最近的位置在哪

或者每个位置都求：

1. 计算左侧比 `nums[i]`大，且距离最近的位置在哪
2. 计算右侧比 `nums[i]` 大，且距离最近的位置在哪

用单调栈的方式可以做到求解过程中，单调栈所有调整的总代价为 $O(n)$，单次操作的均摊代价为 $O(1)$。

## 示例一

要求：

- 对于数组中每个元素 $x$，找到 $x$ 的左右两侧离它最近、且值 **严格小于** 它的元素的位置（注意，数组可能包含重复值）

思路：

1. 维护一个栈，栈中元素必须满足**大压小**的规则（因此也称为单调递减栈）。
2. 遍历阶段：
   1. 遍历数组元素  $arr[i]$，我们记为 $x$，依次将 $x$ 压入栈中。
   2. 如果栈顶元素 $t$ **大于等于** $x$，则弹出 $t$，并收集 $t$ 的信息：
      1. 左边离 $t$ 最近且最小的元素：就是此时新的栈顶元素 $t'$。如果 $t$ 弹出后栈就空了，证明  $t$ 左边没有比它小的元素。
      2. 右边离 $t$ 最近且最小的元素：就是当前的  $x$。

3. 清算阶段：
   1. 遍历数组结束后，如果栈不为空，则依次弹出栈顶元素 $t$ 并收集 $t$ 的信息：
      1. 左边离 $t$ 最近且最小的元素：此时新的栈顶元素 $t'$。如果 $t$ 弹出后栈就空了，证明  $t$ 左边没有比它小的元素
      2. 右边离 $t$ 最近且最小的元素：无。

4. 修正阶段：
   1. 左侧的答案不用修正，一定是正确的，但右侧的答案不一定正确。
   2. 因为如果 $t$ **等于** $x$，我们也会弹出 $t$，所以我们从右往左修正。


```java
public static int[][] computeLess(int[] arr) {
    int n = arr.length;
    int[][] ans = new int[n][2];
    ArrayDeque<Integer> stack = new ArrayDeque<>();
    // 遍历阶段
    for (int i = 0; i < n; i++) {
        int x = arr[i];
        while (!stack.isEmpty() && arr[stack.peek()] >= x) {
            int t = stack.pop();
            ans[t][0] = !stack.isEmpty() ? stack.peek() : -1;
            ans[t][1] = i;
        }
        stack.push(i);
    }
    // 清算阶段
    while (!stack.isEmpty()) {
        int t = stack.pop();
        ans[t][0] = !stack.isEmpty() ? stack.peek() : -1;
        ans[t][1] = -1;
    }
    // 修正阶段（n-1位置的右侧答案一定是-1，不需要修正）
    for (int i = n - 2, r; i >= 0; i--) {
        // 举例：
        // [2, 6, 3, 4, 3, 2]
        //  0  1  2  3  4  5
        //        i     r
        // 如果发现i位置右侧离他最近且最小的元素，竟然和它相等，则需要修正，并修正为右侧答案的答案
        if (ans[i][1] != -1 && arr[ans[i][1]] == arr[i]) {
            ans[i][1] = ans[ans[i][1]][1];
        }
    }
    return ans;
}
```

- `ans[i][0]` 表示数组中第 `i` 个元素，**左侧**离它最近且值严格小于它的元素的位置。
- `ans[i][1]` 表示数组中第 `i` 个元素，**右侧**离它最近且值严格小于它的元素的位置。

## 示例二

要求：

- 对于数组中每个元素 $x$，请找到 $x$ 的左右两侧离它最近、且值 **严格大于** 它的元素的位置（注意，数组可能包含重复值）

思路：

1. 维护一个栈，栈中元素必须满足**小压大**的规则（因此也称为单调递增栈）。
2. 遍历阶段：
   1. 遍历数组元素  $arr[i]$，我们记为 $x$，依次将 $x$ 压入栈中。
   2. 如果栈顶元素 $t$ **小于等于** $x$，则弹出 $t$，并收集 $t$ 的信息：
      1. 左边离 $t$ 最近且最大的元素：就是此时新的栈顶元素 $t'$。如果 $t$ 弹出后栈就空了，证明  $t$ 左边没有比它大的元素。
      2. 右边离 $t$ 最近且最大的元素：就是当前的  $x$。
3. 清算阶段：
   1. 遍历数组结束后，如果栈不为空，则依次弹出栈顶元素 $t$ 并收集 $t$ 的信息：
      1. 左边离 $t$ 最近且最大的元素：此时新的栈顶元素 $t'$。如果 $t$ 弹出后栈就空了，证明  $t$ 左边没有比它大的元素
      2. 右边离 $t$ 最近且最大的元素：无。
4. 修正阶段：
   1. 左侧的答案不用修正，一定是正确的，但右侧的答案不一定正确。
   2. 因为如果 $t$ **等于** $x$，我们也会弹出 $t$，所以我们从右往左修正。

```java
public static int[][] computeGreater(int[] arr) {
    int n = arr.length;
    int[][] ans = new int[n][2];
    ArrayDeque<Integer> stack = new ArrayDeque<>();
    // 遍历阶段
    for (int i = 0; i < n; i++) {
        int x = arr[i];
        while (!stack.isEmpty() && arr[stack.peek()] <= x) {
            int t = stack.pop();
            ans[t][0] = !stack.isEmpty() ? stack.peek() : -1;
            ans[t][1] = i;
        }
        stack.push(i);
    }
    // 清算阶段
    while (!stack.isEmpty()) {
        int t = stack.pop();
        ans[t][0] = !stack.isEmpty() ? stack.peek() : -1;
        ans[t][1] = -1;
    }
    // 修正阶段（n-1位置的右侧答案一定是-1，不需要修正）
    for (int i = n - 2, r; i >= 0; i--) {
        // 如果发现i位置右侧离他最近且最大的元素，竟然和它相等，则需要修正，并修正为右侧答案的答案
        if (ans[i][1] != -1 && arr[ans[i][1]] == arr[i]) {
            ans[i][1] = ans[ans[i][1]][1];
        }
    }
    return ans;
}
```

在上述例子中：

- `ans[i][0]` 存储的是数组中第 `i` 个元素，左侧离它最近且值严格大于它的元素的位置，也就是左侧第一个小于它的元素的位置。
- `ans[i][1]` 存储的是数组中第 `i` 个元素，右侧离它最近且值严格大于它的元素的位置，也就是右侧第一个小于它的元素的位置。
