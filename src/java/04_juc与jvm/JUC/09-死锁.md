---
title: 死锁
category: Java
tag:
  - 多线程
order: 9
icon: uis:process
---


## 可重入锁

### （1）概念

> “对同一个线程，能否在获取到锁以后继续获取同一个锁？答案是肯定的。JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁。”

可重入锁，也称为递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提是锁对象得是同一个对象或者class），不会因为之前已经获取过锁而导致锁的申请失败。

这样的设计就是为了防止死锁。在`Java`中，`synchronized`和`ReentrantLock`都是可重入锁。

### （2）举个栗子

```java
public class ReentrantExample {
    public synchronized void outer() {
        System.out.println("outer thread: " + Thread.currentThread().getName());
        inner();
    }

    public synchronized void inner() {
        System.out.println("inner thread: " + Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        ReentrantExample example = new ReentrantExample();
        new Thread(example::outer, "Thread-1").start();
    }
}
```

比如上述代码中，当`Thread-1`线程在执行`outer`方法时，会先获取到锁，然后进入`inner`方法，由于是同一个线程，所以可以再次获取到锁，这就是可重入锁的特性。

> “由于Java的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出synchronized块，记录-1，减到0的时候，才会真正释放锁。”

## 死锁

### （1）概念

**死锁是指两个或多个线程在执行过程中，因争夺资源而造成的一种相互等待的现象**，若无外力干涨，它们都将无法推进下去。

举个简单的例子，假设有两个线程A和B，以及两个资源1和2。线程A持有资源1，同时等待资源2；线程B持有资源2，同时等待资源1。这样，线程A和B就形成了一个死锁，它们都在等待对方释放资源，但又都不释放自己持有的资源，所以都无法继续执行。死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。

上面提到的可重入锁就是为了防止死锁，一个线程在等待一个它自己已经持有的锁。例如，一个线程在执行一个同步方法时，该方法又调用了另一个同步方法，如果这两个同步方法需要的是同一个锁，那么就会形成死锁。因为外层方法已经持有了锁，内层方法还在等待获取锁，结果就是线程永远无法继续执行。

但是如果锁是可重入的，那么这种情况就可以避免。因为当线程再次请求同一个锁时，如果这个锁已经被它自己持有，那么请求就会成功，而不会形成死锁。

### （2）如何避免死锁？

避免死锁的常见策略：

1. **资源一次性分配**：这种策略是在进程开始时请求所有必需的资源。如果无法满足所有资源，进程就不会开始。这可以避免死锁，但可能导致资源的低效使用。

2. **按顺序请求资源**：为系统中的所有资源定义一个排序，并要求进程按照这个顺序请求资源。这可以防止循环等待，从而避免死锁。

3. **使用预防死锁的协议**：例如，你可以使用银行家算法。这种算法在分配资源之前检查是否安全（即是否可能导致死锁）。如果不安全，就不分配资源。

4. **超时和重试**：如果一个进程长时间无法获取资源，就释放它持有的所有资源，等待一段时间后再试。

5. **死锁检测和恢复**：定期检查系统是否存在死锁。如果检测到死锁，就中止或回滚一些进程，以释放资源。
