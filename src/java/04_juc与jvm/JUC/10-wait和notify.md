---
title: wait和notify
category: Java
tag:
  - 多线程
order: 10
icon: uis:process
---

## 1. 多线程协调

在Java中，多线程编程是常见的，但多个线程之间的协调是一项复杂的任务。

虽然使用 `synchronized` 关键字可以解决多线程竞争的问题，但并不足以解决线程之间的协调。这就引出了 `wait` 和 `notify` 方法，它们允许线程在某些条件下等待或被唤醒，从而更有效地协调线程之间的活动。

> 多线程协调运行原则：
>
> - 当条件不满足时，线程进入等待状态
> - 当条件满足时，线程被唤醒，继续执行任务

多线程协调的核心思想是**条件控制**，即根据条件判断线程是否应该执行。

## 2. wait

### 2.1 等待状态

`wait()` 方法使线程进入等待状态，并且必须在已经获取锁的情况下调用。

当线程调用 `wait()` 方法时，它释放已持有的锁，然后等待另一个线程调用相同对象上的 `notify()` 或 `notifyAll()` 方法来唤醒它。

一旦相同的锁对象上被调用 `notify`方法时，`wait()`方法才会返回，被唤醒的线程重新尝试获取锁，然后继续执行下一条语句。

> 小结：`wait()` 方法必须在**当前线程持有锁**的情况下调用，否则会抛出 `IllegalMonitorStateException` 异常。`wait()` 方法会**释放**当前线程持有的锁，并进入**等待队列**。

### 2.2 执行机制

`wait()`方法的执行机制非常复杂。首先，它不是一个普通的Java方法，而是定义在`Object`类的一个`native`方法，也就是由JVM的C代码实现的。其次，必须在`synchronized`块中才能调用`wait()`方法，因为`wait()`方法调用时，会*释放*线程获得的锁，`wait()`方法返回后，线程又会重新试图获得锁。

因此，只能在锁对象上调用`wait()`方法。当一个线程在`this.wait()`等待时，它就会释放`this`锁，从而使得其他线程能够在其他方法中获得`this`锁。

```java
synchronized (lock) {
    while (condition does not hold) {
        lock.wait();
    }
    // perform action appropriate to condition
}
```

## 3. notify

### 3.1 唤醒

上述提到了，线程在调用`wait`方法后进入等待状态，接着，它会释放线程获得的锁，直到wait方法返回，线程又会重新试图获得锁。那么，如何让等待的线程被重新唤醒，然后从`wait()`方法返回？答案就是在相同的锁对象上调用 `notify`方法。

`notify()` 和 `notifyAll()` 方法用于唤醒等待在对象上的线程。调用这些方法会使等待线程之一或所有等待线程从等待状态返回，并尝试重新获取锁以继续执行。这种唤醒的行为允许线程在适当的时候进行协调和同步。

### 3.2 具体

- `notify()` 方法随机唤醒等待队列中的一个线程，而 `notifyAll()` 方法唤醒所有等待的线程。
- 这些方法必须在已获得锁的情况下调用，以确保在调用时线程安全。
- 唤醒的线程在被唤醒后仍然需要重新获得锁，然后才能继续执行。

> 小结：通常建议使用 `notifyAll()` 方法，避免遗漏唤醒某些线程。