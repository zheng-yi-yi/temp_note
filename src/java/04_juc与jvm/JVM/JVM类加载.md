---
title: JVM类加载与双亲委派模型
category: Java
tag:
  - JVM
order: 2
---



## 类加载器的基本功能

1. **加载**：这是类加载过程的首要任务。加载的过程是由类加载器负责读取Java二进制代码（`.class`文件），并将其内容转化为Java虚拟机可以识别的数据结构（在堆内存中生成一个代表这个类的`java.lang.Class`对象）。

2. **链接**：链接过程主要包括验证、准备和解析三个阶段。验证是为了确保被加载的类的正确性和安全性；准备阶段是为类的静态变量分配内存并设置默认值；解析阶段是将类的符号引用转换为直接引用。

3. **初始化**：初始化阶段是执行类的初始化方法，包括类变量的初始化和执行类的静态初始化块。

4. **卸载**：当一个类不再被引用，或者其对应的Java ClassLoader对象被回收，或者在Java虚拟机关闭的时候，Java虚拟机将会卸载Class对象。

> 备注：每一个类加载器，都拥有一个独立的类名称空间，保证了不同类加载器可以加载同名的类，而这些类又互不相干，是完全独立的。


```
Java类加载过程
├── 加载（Loading）:查找并加载字节码文件（.class文件）,通过类的全限定名查找类文件，将类文件加载到内存中
│   ├── 查找并加载字节码文件（.class文件）通过一个类的全限定名来获取定义此类的二进制字节流。
│   ├── 将字节流代表的静态存储结构转化为方法区的运行时数据结构。
│   └── 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
│
├── 链接（Linking）
│   ├── 验证（Verification）检查类文件的格式、语义等是否符合Java规范
│   │   ├── 文件格式验证：验证字节流是否符合Class文件格式的规范。
│   │   ├── 元数据验证：对字节码进行语义分析，保证其符合Java语言规范。
│   │   ├── 字节码验证：检查字节码流是否包含不正确的或不合法的代码。
│   │   └── 符号引用验证：确保解析后的符号引用可以正确链接到目标。
│   │
│   ├── 准备（Preparation）:为类的静态变量分配内存并初始化默认值
│   │   ├── 为类变量分配内存并设置默认初始值（0、null等）。
│   │   └── 这里的“准备”阶段不会真正初始化类变量的值。
│   │
│   └── 解析（Resolution）:将类、接口、字段和方法的符号引用解析为直接引用
│       ├── 将常量池中的符号引用替换为直接引用。
│       └── 解析过程主要针对类或接口、字段、类方法、接口方法、方法类型等。
│
│── 初始化（Initialization）为类的静态变量赋予正确的初始值、执行静态初始化器和执行静态变量赋值语句
│    ├── 类初始化时机：包括类被首次主动使用（如创建实例、调用静态方法、访问静态字段等）时
│    └── 类初始化的执行顺序：类初始化时，先初始化父类，然后再初始化子类。
│
│── 使用（Using）通过类的引用来使用该类
│   ├── 创建类的实例
│   ├── 调用类的方法
│   └── 访问类的字段
└── 卸载
```

## 四种类型的类加载器

1. **引导类加载器（`Bootstrap ClassLoader`）**：这是最顶层的类加载器，主要负责加载Java的核心类库，如`java.lang.*`，`java.util.*`等。这个类加载器是用C++编写的，是JVM的一部分，它不是一个Java类。

2. **扩展类加载器（`Extension ClassLoader`）**：这个类加载器负责加载JRE的扩展目录（`jre/lib/ext`）中的类库。它是由`sun.misc.Launcher$ExtClassLoader`实现的。

3. **应用类加载器（`Application ClassLoader`）**：这个类加载器负责加载用户类路径（`ClassPath`）上所指定的类库，这也是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载的。它是由`sun.misc.Launcher$AppClassLoader`实现的。

4. **自定义类加载器（`User ClassLoader`）**：Java也允许我们自定义类加载器，我们可以继承`java.lang.ClassLoader`类，然后覆盖`findClass(String name)`方法，实现自己的类加载逻辑。

## 双亲委派模型

双亲委派模型是Java类加载器在加载类时所遵循的一个重要原则。具体来说，这个模型规定：

1. **委派**：如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。这就是所谓的“委派”的概念。

2. **顶层尝试加载**：每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的引导类加载器中。引导类加载器会尝试加载这个类。

3. **子加载器尝试加载**：只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

比如一个定义在`java.lang`包下的类，因为它被存放在`rt.jar`之中，所以在被加载过程中，会被一直委托到`Bootstrap ClassLoader`，最终由`Bootstrap ClassLoader`所加载。

而一个用户自定义的`com.zyy.ClassZyy`类，它也会被一直委托到`Bootstrap ClassLoader`，但是因为`Bootstrap ClassLoader`不负责加载该类，那么会在由`Extention ClassLoader`尝试加载，而`Extention ClassLoader`也不负责这个类的加载，最终就被`Application ClassLoader`加载。